import {format_uptime, till_now_ms, from_ms} from 'util/time'
import {component} from 'util/base'
import websock from 'util/websock'
import {Query} from 'util/query'
import {already_percent_formatter, bytes_formatter} from 'util/format'
import {percent_formatter} from 'util/format'
import sparkline from 'templates/charts/sparkline.mft'
import donut from 'templates/donut.mft'
import {cpu_chart, mem_chart} from 'util/compute'
import {self_cpu} from 'util/navbar'

css:
  .pointer
    cursor: pointer
  .donut, .sparkline
    display: inline-block
    margin-left: 2px
    margin-right: 2px
  .sparkline
    border: solid lightblue 2px
    border-radius: 3px
  .navbar-right
    margin-top: 2px
  .version_string
    font-size: x-small
    position: relative
    top: -4px
  .version
    display: inline

html icon(name):
  span.glyphicon[class="glyphicon-{name}"]

html render_self(beacon, connected, stats):
  span.pointer[title="Uptime of the cantal agent itself"]
    " up "
    =format_uptime(till_now_ms(from_ms(beacon.startup_time)))
  " "
  span.pointer[title="Latency of requests to the cantal"]
    "{beacon.latency:d}ms"
  " "
  span.pointer[title="Time it takes for cantal to read all stats once"]
    "{beacon.scan_duration:d}ms"
  if stats:
    " "
    =bytes_formatter()(stats.fine_metrics.self.rss[0][0])
    "/"
    =already_percent_formatter()(
      stats.fine_metrics.self.user_time[0][0] +
      stats.fine_metrics.self.system_time[0][0])

html render_machine(beacon, stats):
  span.pointer[title="Uptime of the box running cantal"]
    "up "
    =format_uptime(till_now_ms(from_ms(beacon.boot_time)))
  " "
  if stats and stats.fine_metrics:
    span
      let cpu_yaxis = {
        height: 40,
        bg_color: 'rgb(237,248,233)',
        skip_color: "white",
        format: already_percent_formatter(),
        colors: [
          [100, 'rgb(186,228,179)'],
          [200,'rgb(116,196,118)'],
          [800, 'rgb(49,163,84)'],
          [1600, 'rgb(0,109,44)'],
          [6400, "black"]
        ]
      }

      let mem = mem_chart(stats.fine_metrics.memory)
      .donut
        =donut.render(mem.items, 40, 40, mem.total)

      let cpu = cpu_chart(stats.fine_metrics.cpu_sum,
                          stats.fine_metrics.cpu)
      .sparkline
        =sparkline.render(120, stats.fine_timestamps, [{
            'title': 'Cpu',
            'values': cpu['cpu.usage'],
            'yaxis': cpu_yaxis
            }])


html render(current_page):
  div.navbar.navbar-default
    div.container-fluid
      let beacon = websock.last_beacon
      div.navbar-header
        a.navbar-brand[href="#/"]
          "Cantal"
          .version_string
            .version "v0.1.2"
            if beacon:
              " / "
              "{beacon.version}"
      div.collapse.navbar-collapse
        ul.nav.navbar-nav
          li.active?(current_page == 'status')
            a[href="#/status"]
              "Status"
          li.active?(current_page == 'processes')
            a[href="#/processes"]
              "Processes"
              if beacon:
                " [{beacon.processes}]"
          li.active?(current_page == 'metrics')
            a[href="#/metrics"]
              "Metrics"
              if beacon:
                " [{beacon.values}]"
          li.active?(current_page == 'peers')
            a[href="#/peers"]
              "Peers"
              if beacon:
                " [{beacon.peers_with_remote}/{beacon.peers}]"
          li.active?(current_page == 'remote')
            a[href="#/remote"]
              "Remote"
              if beacon:
                if beacon.remote_total == null:
                  " [off]"
                else:
                  " [{beacon.remote_connected}/{beacon.remote_total}]"

        if beacon:
          .navbar-right.bg-danger?(!websock.connected)
            store query = new Query(2000, {
                'self': {
                    'source': 'Fine',
                    'condition': ['eq', 'pid', String(beacon.pid)],
                    'key': ['metric'],
                    'aggregation': 'None',
                    'limit': 2
                    },
                'memory': {
                    'source': 'Fine',
                    'condition': ['regex-like', 'metric', '^memory\\.'],
                    'key': ['metric'],
                    'aggregation': 'None',
                    'limit': 1
                    },
                'cpu_sum': {
                    'source': 'Fine',
                    'condition': ['regex-like', 'metric', '^cpu\\.'],
                    'key': [],
                    'aggregation': 'CasualSum',
                    'limit': 120
                    },
                'cpu': {
                    'source': 'Fine',
                    'condition': ['regex-like', 'metric', '^cpu\\.'],
                    'key': ['metric'],
                    'aggregation': 'None',
                    'limit': 120
                    }
            })
            "("
            =icon('hdd')
            " "
            if beacon:
              =render_machine(beacon, query.response)
            ") ("
            =icon('scale')
            if beacon:
              =render_self(beacon, websock.connected, query.response)
            ") "
