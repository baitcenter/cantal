import {format_uptime, till_now_ms, from_ms} from 'util/time'
import {component} from 'util/base'
import websock from 'util/websock'
import {Query} from 'util/query'
import {already_percent_formatter, bytes_formatter} from 'util/format'
import {percent_formatter} from 'util/format'
import sparkline from 'templates/charts/sparkline.mft'
import donut from 'templates/donut.mft'
import {cpu_usage, mem_chart} from 'util/compute'

css:
  .pointer
    cursor: pointer
  .donut, .sparkline
    display: inline-block
    margin-left: 2px
    margin-right: 2px
  .sparkline
    border: solid lightblue 2px
    border-radius: 3px
  .navbar-right
    margin-top: 2px
  .version_string
    font-size: x-small
    position: relative
    top: -4px
  .version
    display: inline

html icon(name):
  span.glyphicon[class="glyphicon-{name}"]

html render_self(beacon, connected, cpu, mem):
  span.pointer[title="Uptime of the cantal agent itself"]
    " up "
    =format_uptime(till_now_ms(from_ms(beacon.startup_time)))
  " "
  span.pointer[title="Latency of requests to the cantal"]
    "{beacon.latency:d}ms"
  " "
  span.pointer[title="Time it takes for cantal to read all stats once"]
    "{beacon.scan_duration:d}ms"
  if cpu and mem:
    " "
    =bytes_formatter()(mem.rss)
    "/"
    =already_percent_formatter()(cpu.value.value / cpu.delta_sec())

html render_machine(beacon, stats):
  span.pointer[title="Uptime of the box running cantal"]
    "up "
    =format_uptime(till_now_ms(from_ms(beacon.boot_time)))
  " "
  if stats:
    span
      let cpu_yaxis = {
        height: 40,
        bg_color: 'rgb(237,248,233)',
        skip_color: "white",
        format: already_percent_formatter(),
        colors: [
          [100, 'rgb(186,228,179)'],
          [200,'rgb(116,196,118)'],
          [800, 'rgb(49,163,84)'],
          [1600, 'rgb(0,109,44)'],
          [6400, "black"]
        ]
      }

      let mem = mem_chart(stats.get('memory'))
      .donut
        =donut.render(mem.items, 40, 40, mem.total)

      let usage = cpu_usage(stats.get('cpu_total').chunk,
                            stats.get('cpu_idle').chunks[0][1])
      .sparkline
        =sparkline.render(120, stats.get('cpu_total').timestamps, [{
            'title': 'Cpu',
            'values': usage,
            'yaxis': cpu_yaxis
            }])


html render(current_page):
  div.navbar.navbar-default
    div.container-fluid
      let beacon = websock.last_beacon
      div.navbar-header
        a.navbar-brand[href="#/"]
          "Cantal"
          .version_string
            .version "v0.2.3"
            if beacon:
              " / "
              "{beacon.version}"
      div.collapse.navbar-collapse
        ul.nav.navbar-nav
          li.active?(current_page == 'status')
            a[href="#/status"]
              "Status"
          li.active?(current_page == 'processes')
            a[href="#/processes"]
              "Processes"
              if beacon:
                " [{beacon.processes}]"
          li.active?(current_page == 'metrics')
            a[href="#/metrics"]
              "Metrics"
              if beacon:
                " [{beacon.values}]"
          li.active?(current_page == 'peers')
            a[href="#/peers"]
              "Peers"
              if beacon:
                " [{beacon.peers_with_remote}/{beacon.peers}]"
          li.active?(current_page == 'remote')
            a[href="#/remote"]
              "Remote"
              if beacon:
                if beacon.remote_total == null:
                  " [off]"
                else:
                  " [{beacon.remote_connected}/{beacon.remote_total}]"

        if beacon:
          .navbar-right.bg-danger?(!websock.connected)
            store query = new Query(2000, {
                'self_cpu': {
                  'series': {
                    'source': 'Fine',
                    'condition': ['And', ['Eq', 'pid', String(beacon.pid)],
                                         ['RegexLike', 'metric', '_time$']]},
                  'extract': ['DiffToAtMost', 1],
                  'functions': [['Sum', 'Ignore']]
                },
                'self_mem': {
                  'series': {
                    'source': 'Fine',
                    'condition': ['And', ['Eq', 'pid', String(beacon.pid)],
                                         ['Eq', 'metric', 'rss']]},
                  'extract': ['Tip'],
                  'functions': []
                },
                'memory': {
                  'series': {
                    'source': 'Fine',
                    'condition': ['RegexLike', 'metric', '^memory\\.']},
                  'extract': ['Tip'],
                  'functions': []
                },
                'cpu_total': {
                  'series': {
                    'source': 'Fine',
                    'condition': ['RegexLike', 'metric', '^cpu\\.']},
                  'extract': ['HistoryByNum', 120],
                  'functions': [['NonNegativeDerivative'], ['Sum', 'Ignore']]
                },
                'cpu_idle': {
                  'series': {
                    'source': 'Fine',
                    'condition': ['Eq', 'metric', 'cpu.idle']},
                  'extract': ['HistoryByNum', 120],
                  'functions': [['NonNegativeDerivative']]
                }
            })
            "("
            =icon('hdd')
            " "
            if beacon:
              =render_machine(beacon, query.values)
            ") ("
            =icon('scale')
            if beacon:
              =render_self(beacon, websock.connected,
                query.values and query.values.get('self_cpu'),
                query.values and query.values.get('self_mem').to_dict('metric'))
            ") "
